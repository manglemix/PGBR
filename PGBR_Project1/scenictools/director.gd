# A streamlined way to manage scenes, multiple cameras, and user input
class_name Director
extends Node


signal player_changed(node)

export var _player_path: NodePath
export var invert_y := false
export var mouse_sensitivity := 0.001

var player: Spatial setget set_player
var res_directory := Directory.new()


func set_player(node: Spatial):
	if is_instance_valid(player):
		player.user_input = false
	
	player = node
	emit_signal("player_changed", player)
	
	if is_instance_valid(player):
		player.user_input = true


func _ready():
	res_directory.open("res://")
	if res_directory.file_exists("save1.save"):
		read_tree("save1.save")
	set_player(get_node_or_null(_player_path))


static func get_family(owner: Node) -> Array:
	# returns an array of all descendents of the owner given
	var children := owner.get_children()
	
	for child in owner.get_children():
		children += get_family(child)
	
	return children


func get_state(owner: Node) -> Dictionary:
	# stores all the variables of a tree of nodes with the owner being the root node
	if owner.has_method("_prep_state"):
		owner._prep_state()
	
	var states := {}
	var nodes := get_family(owner)
	nodes.insert(0, owner)
	
	for node in nodes:
		var current_state := {
			"name": node.name,
			"groups": node.get_groups(),
		}
		
		# store script variables
		if is_instance_valid(node.get_script()):
			merge_dicts(current_state, inst2dict(node), false)
			current_state.erase("@subpath")		# useless variables generated by inst2dict
			current_state.erase("@path")
			
			if "dont_save" in current_state:
				for name in current_state["dont_save"]:
					current_state.erase(name)
				current_state.erase("dont_save")
		
		# important builtin node variables
		if node is Spatial:
			current_state["transform"] = node.transform
		
		states[owner.get_path_to(node)] = current_state
	
	return states


func get_hierarchy(owner: Node, assert_foreign:=false) -> Dictionary:
	# converts a tree of nodes (with the root node being the owner) into a dict of paths to PackedScenes
	# cannot compensate for individual nodes added through code (if assert_foreign is true, finding these nodes will cause the program to end)
	var children := get_family(owner)
	
	assert(not owner.filename.empty())
	var scenes := {str(get_path_to(owner)): owner.filename}
	
	for child in children:
		# if the node doesn't have an owner, it is loaded dynamically
		if not is_instance_valid(child.owner) or child.owner == self:
			if child.filename.empty():
				# if it wasn't loaded from a PackedScene, the nodes were added individually. We don't support copying of dynamically made hierarchies
				if assert_foreign:
					assert(false)
			else:
				# if there is a filename, it was loaded from a PackedScene
				scenes[str(owner.get_path_to(child))] = child.filename
	
	return scenes


func load_hierarchy(dict: Dictionary) -> Array:
	# converts a dict of paths to PackedScenes into a tree of nodes
	# returns an array of two elements, the first being the root node
	# the second being the rightful parent of the root
	var root: Node
	var root_parent: String
	
	for path in dict:
		var node := load(dict[path]).instance() as Node
		
		if root_parent.empty():
			# the first node in the dict is the root node
			root_parent = "."
			root = node
			continue
		
		var parent: String
		
		if "/" in path:
			var last_idx := path.find_last("/") as int
			parent = path.left(last_idx)
			node.name = path.right(last_idx)
		
		else:
			# if there are no slashes, the path itself is the name of the node
			# and the parent should be the root node
			parent = "."
			node.name = path
		
		root.get_node(parent).add_child(node)
	
	return [root, root_parent]


func load_state(owner: Node, dict: Dictionary) -> void:
	dict = dict.duplicate()
	var nodes := get_family(owner)
	nodes.insert(0, owner)
	
	for node in nodes:
		var current_state := dict[owner.get_path_to(node)] as Dictionary
		if node.has_method("_override_load"):
			node._override_load(current_state)
			continue
		
		if node.has_method("_loading_state"):
			node._loading_state()
		
		# this is also recursive, until the last nodes with no children
		for group in current_state["groups"]:
			node.add_to_group(group)
		current_state.erase("groups")
		
		# setting all properties
		for key in current_state:
			node.set(key, current_state[key])


func write_tree(owner: Node, filename: String, key:=OS.get_unique_id()) -> void:
	var file := File.new()

	if key.empty():
		file.open(filename, File.WRITE)
	else:
		file.open_encrypted_with_pass(filename, File.WRITE, key)
	
	file.store_var([get_hierarchy(owner), get_state(owner)])
	file.close()


func read_tree(filename: String, key:=OS.get_unique_id()) -> void:
	var file := File.new()

	if key.empty():
		file.open(filename, File.READ)
	else:
		file.open_encrypted_with_pass(filename, File.READ, key)
	
	var data := file.get_var() as Array
	var result := load_hierarchy(data[0])
	load_state(result[0], data[1])
	get_node(result[1]).add_child(result[0])
	file.close()


func set_player(node: Spatial):
	if is_instance_valid(player):
		player.user_input = false
	
	player = node
#	$HUD.set_player(player)
	
	if is_instance_valid(player):
		player.user_input = true


func get_branch(node: Node) -> Node:
	for child in get_children():
		if child.is_a_parent_of(node):
			return child
	return null


func is_branch(node: Node) -> bool:
	return node in get_children()


func get_navigation(node: Node) -> Navigation:
	return get_branch(node).get_node("Navigation") as Navigation


func camera_raycast(camera: Camera, distance:= 0.0, exclude:= [], screen_point:= get_viewport().size / 2) -> Dictionary:
	if is_zero_approx(distance):
		distance = camera.far
	
	return get_viewport().world.direct_space_state.intersect_ray(camera.global_transform.origin, camera.project_position(screen_point, distance), exclude)


func current_camera_raycast(distance:=0.0, exclude:=[], screen_point:= get_viewport().size / 2) -> Dictionary:
	return camera_raycast(get_viewport().get_camera(), distance, exclude, screen_point)


func _input(event):
	if event.is_action_pressed("ui_cancel"):
		get_tree().paused = true
		write_tree($Draft, "save1.save")
		get_tree().quit()
	
	if event.is_action_pressed("debug"):
		Debug.enabled = not Debug.enabled


static func merge_dicts(dict1: Dictionary, dict2: Dictionary, duplicate:=true) -> Dictionary:
	if duplicate:
		dict1 = dict1.duplicate()
	
	for key in dict2:
		dict1[key] = dict2[key]
	
	return dict1
